<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>zeromq.device documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Cljzmq 0.1.2 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="zeromq.device.html"><span>zeromq.device</span></a></li><li><a href="zeromq.receivable.html"><span>zeromq.receivable</span></a></li><li><a href="zeromq.sendable.html"><span>zeromq.sendable</span></a></li><li><a href="zeromq.zmq.html"><span>zeromq.zmq</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="zeromq.device.html#var-proxy"><span>proxy</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>zeromq.device documentation</h2><pre class="doc"></pre><div class="public" id="var-proxy"><h3>proxy</h3><div class="usage"><code>(proxy context frontend backend)</code><code>(proxy context frontend backend capture)</code></div><pre class="doc">The proxy function starts the built-in Ã˜MQ proxy in the current application
 thread.

The proxy connects a frontend socket to a backend socket. Conceptually, data
flows from frontend to backend. Depending on the socket types, replies may
flow in the opposite direction. The direction is conceptual only; the proxy
is fully symmetric and there is no technical difference between frontend and
backend.

Before calling proxy you must set any socket options, and connect or bind
both frontend and backend sockets. The two conventional proxy models are:

proxy runs in the current thread and returns only if/when the current context
is closed.</pre><div class="src-link"><a href="http://github.com/zeromq/cljzmq/blob/master/src/zeromq/device.clj#L7">Source</a></div></div></div></body></html>